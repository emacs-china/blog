<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Sort Sexps</title>
        <link rel="icon" type="image/png" href="https://emacs-china.org/uploads/default/original/1X/477ac7ed14175dfd2deb65ee3c3d83d18a8906b8.ico">
        <link href=../../../../feed.xml rel="alternate" type="application/atom+xml">
    </head>
    <body>
        <div>
            <a href="../../../../">首页</a>
        </div>
        <div id="content">
            
<div class="post">
    <h1>Sort Sexps</h1>
    <p>Posted on 2017.08.19, by Chunyang Xu</p>
    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p>最近碰到一个需要排序代码的情况，在给 Org Babel 添加了很多语言之后，顺序完全没规律，看起来不方便，给语言按照字母表排个序就好了：</p>

<pre class="prettyprint"><code class="language-el">(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (sh         . t)
   (lisp       . t)
   (org        . t)
   (perl       . t)
   (R          . t)
   (ruby       . t)
   (python     . t)
   (scheme     . t)
   (C          . t)
   (ditaa      . t)
   (latex      . t)
   (awk        . t)
   (lua        . t)))
</code></pre>

<p>这个格式已经很整齐了，稍微再整理下用 <code>M-x sort-lines</code> 或 <code>C-u M-| sort</code> 就能达到目的，但是如果排序的单元不以行为单位，比如：</p>

<pre class="prettyprint"><code class="language-el">((emacs-lisp . t) (sh . t) (lisp . t) (org . t) (perl . t) (ruby . t))
</code></pre>

<p>这种方法无能为力了。受到网上一些讨论的启发，用 <code>sort-subr</code> 结合 Emacs Syntax Table 能解决问题：</p>

<ul>
  <li>
<code>sort-subr</code> 函数是排序 Buffer 的内容的底层函数，调用者可以设置排序的元素的范围和如何比较它们</li>
  <li>
<code>(skip-syntax-forward "-.&gt;")</code> 分别跳过 Sexps 之间的空白字符(<code>-</code>)、标点符号(<code>.</code>)和换行符号(<code>&gt;</code>)</li>
</ul>

<pre class="prettyprint"><code class="language-el">(defun sort-sexps (reverse beg end)
  "Sort sexps in the Region."
  (interactive "*P\nr")
  (save-restriction
    (narrow-to-region beg end)
    (goto-char (point-min))
    (let ((nextrecfun (lambda () (skip-syntax-forward "-.&gt;")))
          (endrecfun  #'forward-sexp))
      (sort-subr reverse nextrecfun endrecfun))))
</code></pre>

<p>Emacs 把 Lisp 的 Sexp 的概念扩展到了其他的语言</p>

<blockquote>
  <p>Basically, a sexp is either a balanced parenthetical grouping, a string, or a
symbol</p>
</blockquote>

<p>比方说同一个段文字 <code>3 + 2 + 1</code>，在下面的 C 代码中，其中 <code>3</code>, <code>2</code> <code>1</code> 分别都是 Sexp，而剩余的空格和操作符号 <code>+</code> 不是，从而导致了 <code>M-x sort-sexps</code> 只排序 <code>3</code>, <code>2</code>, <code>1</code></p>

<pre class="prettyprint"><code class="language-c">/* -*- mode: c; -*- */
int x = 3 + 2 + 1;
/* M-x sort-sexps */
int x = 1 + 2 + 3;
</code></pre>

<p>而在 Emacs Lisp 代码中，<code>3</code>, <code>+</code>, <code>2</code>, <code>+</code>, <code>1</code> 都是 Sexp，所以它们都会被排序。</p>

<pre class="prettyprint"><code class="language-el">;; -*- mode: emacs-lisp; -*-
(setq x '(3 + 2 + 1))
;; M-x sort-sexps
(setq x '(+ + 1 2 3))
</code></pre>

<p>排序一个 C 字符串数组也能得到预期的结果：</p>

<pre class="prettyprint"><code class="language-c">/* -*- mode: c; -*- */
char *characters[] = { "Tom", "Jerry", "Nibbles", "Quacker" };
/* M-x sort-sexps */
char *characters[] = { "Jerry", "Nibbles", "Quacker", "Tom" };
</code></pre>

<p><code>sort-sexps</code> 用的是 <code>sort-subr</code> 默认的比较方法（即用 <code>string&lt;</code> 比较整个 Record），通过设置 <code>sort-subr</code> 的参数可以做调整。比如按照数字的大小</p>

<pre class="prettyprint"><code class="language-el">(defun sort-numbers (reverse beg end)
  "Sort numbers in the Region."
  (interactive "*P\nr")
  (save-restriction
    (narrow-to-region beg end)
    (goto-char (point-min))
    (let ((nextrecfun (lambda () (skip-syntax-forward "-.&gt;")))
          (endrecfun  #'forward-sexp)
          (startkeyfun (lambda ()
                         (or (number-at-point)
                             (user-error "Sexp doesn't looks like a number")))))
      (sort-subr reverse nextrecfun endrecfun startkeyfun))))


'(3 1 4 10 2)

;; sort-sexps
'(1 10 2 3 4)

;; sort-numbers
'(1 2 3 4 10)
</code></pre>
</body></html>

</div>

<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=lisp"></script>

<div id='discourse-comments'></div>
<script type="text/javascript">
 DiscourseEmbed = { discourseUrl: 'https://emacs-china.org/',
                    discourseEmbedUrl: 'https://emacs-china.github.io/blog/2017/08/19/sort-sexps/' };

 (function() {
     var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
     d.src = DiscourseEmbed.discourseUrl + 'javascripts/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
 })();
</script>

        </div>
    </body>
</html>

